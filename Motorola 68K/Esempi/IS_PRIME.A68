	ORG	$8000
START:
	MOVE.W	#64,-(SP)
	BSR	IS_PRIME
	MOVE.W	(SP)+,D0

	MOVE.W	#65,-(SP)
	BSR	IS_PRIME
	MOVE.W	(SP)+,D1

	MOVE.W	#71,-(SP)
	BSR	IS_PRIME
	MOVE.W	(SP)+,D2

END	JMP END

IS_PRIME:
*divide N da #2 a n
	LINK	A6,#0
	MOVE.W	D0,-(SP)	ESEGUO IL BACKUP DEI REGISTRI CHE UTILIZZO
	MOVE.W	D1,-(SP)
	MOVE.W	D2,-(SP)
	MOVE.L	#0,D0
	MOVE.W	8(A6),D0	D0 CONTIENE IL NUMERO CHE DOBBIAMO CONTROLLARE
	BTST		#0,D0		SE IL PRIMO BIT è 0, IL NUMERO è PARI, NON DEVO CONTROLLARE ALTRO
	BEQ		.RETURN_YES
	MOVE.L	#3,D1		D1 CONTIENE IL DIVISORE I-ESIMO CHE ANDREMO A TESTARE
.LOOP:
	MOVE.L	D0,D2		D2 CONTIENE IL DIVIDENDO
	DIVU.W	D1,D2		D2.w CONTIENE IL QUOZIENTE TRA D2 E D1
	SWAP		D2		D2.w CONTIENE IL RESTO
	CMP.W	#0,D2
	BEQ		.RETURN_YES
	ADDI.W	#2,D1
	CMP.W	D0,D1
	BLT		.LOOP
	MOVE.W	#1,8(A6)	NUMERO PRIMO
	JMP		.RETURN
.RETURN_YES:
	MOVE.W	#0,8(A6)	DIVISORE TROVATO, NUMERO NON PRIMO
.RETURN:
	MOVE.W	(SP)+,D2
	MOVE.W	(SP)+,D1
	MOVE.W	(SP)+,D0
	UNLK	A6
	RTS

	END START



